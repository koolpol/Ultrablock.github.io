<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ULTRABLOCK: PRO MAX (Harder!)</title>
    <style>
        body { margin: 0; background: black; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: monospace; color: white; }
        .game-container { position: relative; }
        canvas { background: #111; border: 4px solid red; box-shadow: 0 0 30px red; }
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        #game-over-screen h1 { color: red; font-size: 3em; }
        #game-over-screen p { font-size: 1.5em; }
        #game-over-screen button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background: red;
            color: white;
            border: none;
            box-shadow: 0 0 10px red;
        }
    </style>
</head>
<body>
<div class="game-container">
    <canvas id="game" width="400" height="600"></canvas>
    <div id="game-over-screen">
        <h1>GAME OVER</h1>
        <p>You fell into the void!</p>
        <button onclick="restartGame()">Try Again</button>
    </div>
</div>

<script>
    /* ================= CORE ================= */
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const gameOverScreen = document.getElementById("game-over-screen");
    let keys = {};
    let frame = 0;
    let gameOver = false;
    let stage = 0; 
    let platforms = []; // Global platform array

    document.addEventListener("keydown", (e) => keys[e.key] = true);
    document.addEventListener("keyup", (e) => keys[e.key] = false);

    /* ================= PLAYER ================= */
    const player = {
        x: 190,
        y: 530,
        w: 20,
        h: 20,
        vx: 0,
        vy: 0,
        speed: 5,
        jump: 12,
        gravity: 0.8, // Increased gravity for faster falls
        friction: 0.85, // Added friction for slippery movement
        onGround: false,
        color: "#ff0000", // Changed player color to match red theme
        reset() {
            this.x = 190; 
            this.y = 530;
            this.vx = 0;
            this.vy = 0;
            this.onGround = false;
            gameOver = false;
            stage = 0;
            gameOverScreen.style.display = 'none';
        },
        update() {
            // Slippery Movement
            if (keys.ArrowLeft) this.vx += -this.speed * 0.2; // Acceleration
            else if (keys.ArrowRight) this.vx += this.speed * 0.2;
            else this.vx *= this.friction; // Apply friction when no keys pressed

            // Cap max speed
            this.vx = Math.max(-this.speed, Math.min(this.speed, this.vx));


            if (keys.ArrowUp && this.onGround) {
                this.vy = -this.jump;
                this.onGround = false;
            }

            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;

            if (this.x < 0) this.x = 0;
            if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
            if (this.y > canvas.height) gameOver = true;
        },
        draw() {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.shadowBlur = 0;
        }
    };

    /* ================= PLATFORM MANAGER & HARDER PLATFORMS ================= */

    // Platform types: "static", "moving", "falling"
    function createPlatform(x, y, w, h, type = "static", vx = 0, vy = 0) {
        return { x, y, w, h, type, vx, vy, initialY: y, active: true };
    }

    function generateStage(stageNum) {
        platforms = [];
        // Base platform
        platforms.push(createPlatform(0, 550, canvas.width, 50, 'static'));

        // Generate more random, varied platforms
        for (let i = 0; i < 15 + stageNum * 2; i++) {
            let x = Math.random() * (canvas.width - 100);
            // Distribute platforms evenly
            let y = canvas.height - 100 - (i * 40); 
            let w = 60 + Math.random() * 40;
            
            // Introduce moving and falling platforms as stages progress
            let type = 'static';
            if (stageNum >= 1 && Math.random() > 0.6) {
                type = 'moving';
            } else if (stageNum >= 2 && Math.random() > 0.7) {
                type = 'falling';
            }

            let vx = (type === 'moving' || Math.random() > 0.8) ? (Math.random() > 0.5 ? 1 : -1) * (1 + stageNum * 0.5) : 0;
            
            platforms.push(createPlatform(x, y, w, 10, type, vx));
        }
    }

    function updatePlatforms() {
        // Check if player reaches the top (new stage trigger)
        if (player.y < 100) {
            stage++;
            generateStage(stage);
            player.y = 500; // Reset player lower down for next set of platforms
            // Increase game speed/gravity slightly for next stage
            player.speed += 0.5;
            player.jump += 0.5;
            player.gravity += 0.05;
        }

        platforms = platforms.filter(p => p.active && p.y < canvas.height);

        platforms.forEach(p => {
            if (p.type === 'moving') {
                p.x += p.vx;
                if (p.x < 0 || p.x + p.w > canvas.width) {
                    p.vx *= -1;
                }
            } else if (p.type === 'falling') {
                // Falling platforms activate only when stepped on
                if (p.falling) {
                    p.vy += 0.5; // Simple falling gravity
                    p.y += p.vy;
                }
            }
        });
    }

    function drawPlatforms() {
        platforms.forEach(p => {
            ctx.fillStyle = "#aaa";
            if (p.type === 'moving') ctx.fillStyle = "#00ff00";
            if (p.type === 'falling') ctx.fillStyle = "#ffaa00";
            
            ctx.fillRect(p.x, p.y, p.w, p.h);
        });
    }

    /* ================= COLLISION DETECTION ================= */
    function checkCollisions() {
        player.onGround = false;
        platforms.forEach(p => {
            // AABB collision detection
            if (player.x < p.x + p.w &&
                player.x + player.w > p.x &&
                player.y < p.y + p.h &&
                player.y + player.h > p.y) {

                // Check collision from top
                if (player.vy >= 0 && player.y + player.h <= p.y + p.h && player.y + player.h >= p.y - 5) {
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.onGround = true;
                    // If it's a falling platform, activate the fall mechanism
                    if (p.type === 'falling') {
                        setTimeout(() => p.falling = true, 300); // 0.3 second delay before falling
                    }
                }
                
                // (Optional: add side collisions if needed, but not necessary for a jump game)
            }
        });
    }

    /* ================= GAME LOOP ================= */
    function gameLoop() {
        if (gameOver) {
            gameOverScreen.style.display = 'flex';
            return; // Stop the loop
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        updatePlatforms();
        player.update();
        checkCollisions();
        
        drawPlatforms();
        player.draw();

        // Draw Stage Info
        ctx.fillStyle = "white";
        ctx.font = "16px monospace";
        ctx.fillText(`Stage: ${stage + 1}`, 10, 20);
        ctx.fillText(`Y Pos: ${Math.floor(550 - player.y + stage * 500)}`, 10, 40);


        requestAnimationFrame(gameLoop);
    }

    function restartGame() {
        player.reset();
        generateStage(0); // Start at stage 0 again
        requestAnimationFrame(gameLoop);
    }

    // Initialize the game
    generateStage(0); 
    gameLoop();
</script>
</body>
</html>
