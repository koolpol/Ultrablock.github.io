<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Shifting Void</title>
    <style> body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #333;
    color: white;
    font-family: monospace;
    flex-direction: column;
}

canvas {
    background-color: #000;
    border: 2px solid white;
}

#gameStats {
    margin-top: 20px;
    text-align: center;
}

#currentRule {
    color: cyan;
}
 </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    <div id="gameStats">
        <p>Score: <span id="score">0</span></p>
        <p>Time (s): <span id="time">0</span></p>
        <p>Rule: <span id="currentRule">Normal Movement</span></p>
    </div>
    <script> const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const timeElement = document.getElementById('time');
const ruleElement = document.getElementById('currentRule');

let player = {
    x: 50,
    y: canvas.height / 2,
    radius: 10,
    color: 'red',
    speed: 3,
    dx: 0,
    dy: 0,
};

let obstacles = [];
let score = 0;
let time = 0;
let gameOver = false;
let currentRule = 'Normal Movement';
let rules = [
    { name: 'Normal Movement', update: () => { player.dx = 0; player.dy = 0; } },
    { name: 'Inverse Controls', update: () => { player.dx *= -1; player.dy *= -1; } },
    { name: 'Hyper Speed', update: () => { player.speed = 6; } },
    { name: 'Slow Motion', update: () => { player.speed = 1; } },
    { name: 'Gravity Shift (Down)', update: () => { player.dy += 0.3; } },
    { name: 'Gravity Shift (Up)', update: () => { player.dy -= 0.3; } },
    { name: 'No Edges (Wrap)', update: () => { /* Handled in updatePlayer */ } },
];

// Event Listeners
document.addEventListener('keydown', handleInput);
document.addEventListener('keyup', handleInput);

function handleInput(e) {
    if (gameOver) return;

    let moveX = 0;
    let moveY = 0;

    if (e.key === 'ArrowUp' || e.key === 'w') moveY = -1;
    if (e.key === 'ArrowDown' || e.key === 's') moveY = 1;
    if (e.key === 'ArrowLeft' || e.key === 'a') moveX = -1;
    if (e.key === 'ArrowRight' || e.key === 'd') moveX = 1;

    // Apply current rule's effect on input
    let ruleIndex = rules.findIndex(r => r.name === currentRule);
    if (ruleIndex === 1) { // Inverse Controls
        player.dx = -moveX * player.speed;
        player.dy = -moveY * player.speed;
    } else {
        player.dx = moveX * player.speed;
        player.dy = moveY * player.speed;
    }
}

// Game Functions

function updatePlayer() {
    player.x += player.dx;
    player.y += player.dy;

    // Boundary conditions
    if (currentRule === 'No Edges (Wrap)') {
        if (player.x < 0) player.x = canvas.width;
        if (player.x > canvas.width) player.x = 0;
        if (player.y < 0) player.y = canvas.height;
        if (player.y > canvas.height) player.y = 0;
    } else {
        if (player.x < player.radius || player.x > canvas.width - player.radius) {
            player.dx *= -1; // Bounce
        }
        if (player.y < player.radius || player.y > canvas.height - player.radius) {
            player.dy *= -1; // Bounce
        }
    }
}

function createObstacle() {
    const radius = 10;
    const x = canvas.width + radius;
    const y = Math.random() * (canvas.height - radius * 2) + radius;
    const speed = Math.random() * 2 + 1;
    obstacles.push({ x, y, radius, speed, color: 'cyan' });
}

function updateObstacles() {
    for (let i = 0; i < obstacles.length; i++) {
        obstacles[i].x -= obstacles[i].speed;
        // Remove off-screen obstacles
        if (obstacles[i].x < -obstacles[i].radius) {
            obstacles.splice(i, 1);
            i--;
            score++;
        }
    }
}

function checkCollision() {
    for (const obstacle of obstacles) {
        const dx = player.x - obstacle.x;
        const dy = player.y - obstacle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < player.radius + obstacle.radius) {
            gameOver = true;
            break;
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw player
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
    ctx.fill();

    // Draw obstacles
    for (const obstacle of obstacles) {
        ctx.fillStyle = obstacle.color;
        ctx.beginPath();
        ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

function updateGameStats() {
    scoreElement.textContent = score;
    timeElement.textContent = Math.floor(time);
    ruleElement.textContent = currentRule;
}

function changeRule() {
    // Reset speeds before applying new rule
    player.speed = 3;
    const newRule = rules[Math.floor(Math.random() * rules.length)];
    currentRule = newRule.name;
    // Apply specific rule update logic if needed
    if (newRule.update) newRule.update();
}

function gameLoop(timestamp) {
    if (gameOver) {
        ctx.fillStyle = 'white';
        ctx.font = '40px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over! Score: ' + score, canvas.width / 2, canvas.height / 2);
        ctx.font = '20px monospace';
        ctx.fillText('Refresh to restart', canvas.width / 2, canvas.height / 2 + 40);
        return;
    }

    // Time tracking
    if (!gameLoop.startTime) gameLoop.startTime = timestamp;
    time = (timestamp - gameLoop.startTime) / 1000;

    // Logic updates
    updatePlayer();
    updateObstacles();
    checkCollision();
    updateGameStats();
    draw();

    requestAnimationFrame(gameLoop);
}

// Initial setup
setInterval(createObstacle, 500); // More frequent obstacles for difficulty
setInterval(changeRule, 6000); // Change rules every 6 seconds (6 7 and cool)
requestAnimationFrame(gameLoop);
 </script>
</body>
</html>
